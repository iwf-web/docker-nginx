content_by_lua_block {
    local http = require "resty.http"
    local cjson = require "cjson"
    local io = require "io"
    local os = require "os"
    local upload = require "resty.upload"

    local CLAMAV_SCAN_PATH = os.getenv("SCAN_PATH")
    local CLAMAV_HOST = os.getenv("CLAMAV_HOST")
    local CLAMAV_PORT = os.getenv("CLAMAV_PORT")
    local CLAMAV_FORWARD_ROUTE = os.getenv("FORWARD_ROUTE")

    -- Function to generate a temporary filename
    local function generate_temp_filename()
        return CLAMAV_SCAN_PATH .. "/tempfile_" .. ngx.time() .. "_" .. math.random(1000, 9999)
    end


    -- decode the multipart form data stuff...
    local chunk_size = 4096
    -- setting the third parameter to "true" preserves the body so that we can retrieve the original body later
    local form, err = upload:new(chunk_size, 512, true)
    if not form then
        ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
        ngx.say(cjson.encode({ status = "error", message = "Failed to initialize upload: " .. err }))
        return
    end

    form:set_timeout(5000) -- 5 sec

    local file
    local temp_filename = generate_temp_filename()

    -- we assume only one file in the multipart definition and overwrite the previous if there are more
    while true do
        local typ, res, err = form:read()
        if not typ then
            ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
            ngx.say(cjson.encode({ status = "error", message = "Failed to read form: " .. err }))
            return
        end

        if typ == "header" then
            local name = res[1]
            if name == "Content-Disposition" then
                local filename = ngx.re.match(res[2], 'filename="(.*)"')
                if filename then
                    file = io.open(temp_filename, "wb")
                    if not file then
                        ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                        ngx.say(cjson.encode({ status = "error", message = "Failed to open file for writing" }))
                        return
                    end
                end
            end

        elseif typ == "body" then
            if file then
                file:write(res)
            end

        elseif typ == "part_end" then
            if file then
                file:close()
                file = nil
            end

        elseif typ == "eof" then
            break
        end
    end


    -- now let clamav scan the file
    local httpc = http.new()
    httpc:set_timeout(60000 * 3) -- timeout is 3 minutes for virus scanning
    local res, err = httpc:request_uri("http://" .. CLAMAV_HOST .. ":" .. CLAMAV_PORT .. "/scanFile?path=" .. temp_filename, {
        method = "GET",
        headers = {
            ["Content-Type"] = ngx.req.get_headers()["Content-Type"],
        }
    })

    -- and delete it...
    os.remove(temp_filename)

    if not res then
        ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
        ngx.say(cjson.encode({ status = "error", message = "Failed to connect to virus scanner: " .. err }))
        return
    end

--[[
if res then
        ngx.status = 200
        ngx.say(cjson.encode({ status = "error", message = "response from clamav: " .. res.body .. " code " ..res.status }))
        return
    end
]]

    -- decode the clamav response
    local status_code = res.status

    local ok, body = pcall(cjson.decode, res.body)
    if not ok then
        ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
        ngx.say(cjson.encode({ status = "error", message = "Failed to decode response from virus scanner: " .. res.body }))
        return
    end

    if status_code == 406 then
        ngx.status = 406
        ngx.say(cjson.encode({ status = "error", message = "Virus detected: " .. body.Description }))
        return
    end

    if status_code == 400 or status_code == 412 or status_code == 501 then
        ngx.status = 500
        ngx.say(cjson.encode({ status = "error", message = "General error while scanning this file: " ..res.body }))
        return
    end


    -- retrieve the original body for forwarding
    ngx.req.read_body()
    local raw_body_content = ngx.req.get_body_data()

    if not raw_body_content then
        -- The request may have been written to disk as it's too large
        local nginx_body_tmp_file_name = ngx.req.get_body_file()
        if nginx_body_tmp_file_name then
            -- Read the original raw body content
            local raw_file = io.open(nginx_body_tmp_file_name, "rb")
            raw_body_content = raw_file:read("*all")
            raw_file:close()
        else
            ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
            ngx.say(cjson.encode({ status = "error", message = "Failed to read request body" }))
            return
        end
    end

    -- Forward to PHP-FCGI server
    ngx.req.set_uri(CLAMAV_FORWARD_ROUTE, false)
    ngx.req.set_method(ngx.HTTP_POST)
    ngx.req.set_body_data(raw_body_content)
    ngx.req.clear_header("Content-Length")
    ngx.req.set_header("Content-Length", #raw_body_content)
    ngx.exec(CLAMAV_FORWARD_ROUTE)

    return
}
